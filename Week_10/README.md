# 学习思路
    运用五遍刷题法，不死磕某个题目，一般超过五分钟没有思路，直接看题解，同时要去看国际站上优秀的题解。
    定期进行复习，因为过一定时间之后，题解可能就忘记，温故而知新。做题时要不断尝试去找最小重复性，化大
    为小，划分为重复子问题进行求解。
# 基础数据结构
## 数组 
    存储空间连续，可通过下表访问，查询效率高。但是插入删除操作，需要移动目标位置之后所有元素，
    极端情况时间复杂度可能退化为O(N).
## 链表
    存储空间不需要连续，每个节点都有指针指向下一个节点。插入删除操作时，只需要更改节点指针指
    向即可。而查询操作时，因为单向链表只能向前，不能向后遍历，因此每次查询时，需要从头结点开
    始遍历，查询时间复杂度较高为O(N).
## 跳表
    基于链表实现，有层级索引概念。每一层会从下一层抽取部分节点，形成一个新的索引链表，新链表
    的节点，会有个指针指向下层节点。依次网上，层级索引多，查找效率高。实现简单，主要用于替换avl
    或者红黑树，redis中使用。
## 栈、队列、优先队列、双端队列
    栈先进后出 FILO， 队列FIFO，先进先出。优先队列主要是以二叉堆的形式，对插入元素进行排序处理，
    时间复杂度 O(logN)。
## 树 二叉树 二叉搜索树
    是一个二维结构，可以有多个分支的树形结构，二叉树的每个节点分支最多只有两个分支，分为左右子树。
    二叉搜索树是一个有序的二叉树，中序遍历是升序。查询时间复杂度是O(logN). 
    二叉树的遍历有前序遍历（根左右），中序遍历（左根右），后续遍历（左右根），以及层序遍历
    （需要借助 stack 或者 deque进行操作，迭代方式的遍历也需要借助辅助栈结构，递归方式就比较简单）。
## 堆 二叉堆
    从一堆数据中找最大节点或者最小节点，根节点最大则为大顶堆，反之最小则为小顶堆，查找最大最小值
    的时间复杂度为O(1),而删除插入操作时间复杂度O(logN)。二叉堆是一个完全二叉树，可以用数组存储。
    i为根节点，那么 2 * i + 1 为左节点，2*i+2为右节点。
## 分治法 
    将大问题划分为子问题，对子问题进行求解，在将子问题结果进行合并，即得到最终的结果。常见的归并
    排序即是用到了分治思想。
## 动态规划
    动态规划最关键的就是找到状态转移方程，以及对边界条件的处理，一般求最优解都可以用动态规划去求。
    
